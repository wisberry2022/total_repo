# Redux Introduce


redux는 상태관리 라이브러리로, 리액트 없이 사용할 수도 있으며 리액트에서도 사용할 수 있다. 리액트에서는 구조가 단순하고 관리해야 할 state가 많지 않을 경우 굳이 Redux를 도입할 필요는 없지만, 구조가 복잡하고 state의 개수가 늘어난다면 Redux 도입이 필요하다.

state가 많아지면 depth가 깊은 컴포넌트에 전달해주려고 하면, 목표 컴포넌트까지 존재하는 중간 컴포넌트들에게 계속 props를 전달해야 한다. 그 과정에 실수가 발생할 수도 있고, props 이름을 변경해야 할 때 번거롭다. 이러한 행위를 `state Drilling`이라고 한다.

Redux를 사용하면 하나의 store를 통해 모든 state와 상태 관리 로직을 저장, 유지할 수 있게 되며, 원하는 Component로만 data를 전달할 수 있다


## Redux의 장점


- 컴포넌트들의 상태 관련 로직들을 다른 파일들로 분리시켜 효율적으로 관리할 수 있다. 컴포넌트끼리 상태를 공유하게 될 때 여러 컴포넌트를 거치지 않고도 손쉽게 상태 값을 전달할 수 있다
- Redux는 단방향 데이터 흐름으로 이루어져 있기 때문에 데이터의 흐름을 예측하기 쉽다
- Redux Middleware라는 기능을 통해 비동기 작업, 로깅 등의 확장적인 작업들을 더욱 쉽게 할 수 있다


## Redux의 3원칙


Redux를 사용하면서 반드시 지켜야 할 3가지 원칙이 있다. 내용은 아래와 같다.

1. 하나의 어플리케이션 안에는 하나의 Store만 존재한다.
2. 상태(state)는 읽기전용(read-only)이다.
3. Reducer는 '순수함수'여야 한다.


### 하나의 어플리케이션 안에는 하나의 Store만 존재한다

여러개의 스토어를 생성하는 것은 Redux에서 권장하는 방식이 아니다. dispatcher 동작 간에 하나의 스토어 상태를 구독하는데, 해당 스토어가 어딘지 찾기 어려워진다는 문제점이 생긴다.

따라서 여러가지 Reducer를 만들어야 한다면,  `combineReducers`를 통해 하나의 store로 생성하는 과정이 필요하다.

### 상태(state)는 읽기전용(read-only)이다.

Redux는 기존 상태에 간섭하지 않으면서 새로운 상태 객체를 생성하여 상태를 업데이트 해준다. 이를 위해 `spread-syntax(...)`나 `concat`, `Object.assign` 등을 사용하여야 한다.

Redux에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경되는 것을 감지하기 위해 shallow equality 검사를 하기 때문이다. 이를 통하여 객체의 변화를 감지할 때 객체의 내부를 완전하게 비교하는 것이 아니라, 겉핥기 식으로 비교를 하여 좋은 성능을 도모한다.

### Reducer는 '순수함수'여야 한다.

순수함수는 동일한 인풋에 언제나 동일한 아웃풋을 출력할 수 있어야 한다. 즉, 같은 인자로 호출된 Reducer 함수는 언제나 똑같은 결과값을 반환해야 한다.

`Reducer` 함수는 파라미터로 state와 action 객체를 받는데, 이 때 Reducer 함수는 인자로 받아온 state는 변경하지 않고, action을 통해 변경한 새로운 state 객체를 만들어서 반환해야 한다



