
각 프로젝트마다 규모나 설계자의 생각에 따라 패키지 구조를 정한다. 패키지 구조는 프로그램이 단순히 동작하게하는데에는 크게 중요하지 않을 수도 있으나, 프로그램을 파악하는데 도움이 되며 설계의 사상을 반영한다.


# 1. 계층 기반 패키지
***
가장 단순하고 전통적인 아키텍처다. 기술적인 관점의 계층에 기반하여 코드를 분할한다.

![[Pasted image 20230319093957.png]]

계층을 웹(Controller), 업무 규칙(Service), 영속성(Repository)로 나누었다. 패키지는 항상 아래 방향으로만 의존한다.

이런 패키지 구조는 웹, 업무규칙, 영속성 계층으로 나누어져있다는 것과 Spring MVC일 것 같다는 정보를 표현한다. 주문과 관련된 코드가 있다라는 도메인에 대한 정보를 제공하지 않는다. 만약 이런 도메인이 많을 때 주문정보를 고쳐야겠다면 어느 부분을 고쳐야할지 찾는데 수고가 든다.

프로젝트 규모가 비교적 소규모거나, 복잡한 구조가 아니라면 이런 계층구조가 도움이 된다.


# 2. 기능 기반 패키지
***

기능 기반 패키지 구조는 연관 개념이나, 도메인, Aggregate Root에 기반하여 코드를 나누는 방식이다. 같은 도메인 개념내의 코드라면 하나의 패키지 구조로 몰아 넣는다.

![[Pasted image 20230319095713.png]]

계층 기반 패키지와 달리 주문에 대한 코드들이 orders 하위의 패키지로 모두 포함되었다. 이 패키지 구조는 읽는 사람에게 "주문에 대한 정보를 포함하고 있다"라는 사실을 인지시켜서 도메인 개념을 표현한다.


# 3. 포트와 어댑터
***
Controller, Service, Repository를 나눈 이유는 세부사항으로부터 업무로직을 보호하기 위함이다. 이를 위해 웹 계층이나 데이터베이스 계층으로부터 업무 로직이 분리되어야한다. 도메인(업무규칙)을 '내부'라고 하고 나머지를 '외부'라고 한다면 의존성은 외부가 내부를 향해야 한다.

![[Pasted image 20230319100243.png]]

외부(세부사항)인 Controller와 Jdbc 데이터베이스가 내부(도메인)에 의존하고 있다. OrdersRepository도 Orders로 이름이 변경되었다. 이는 DDD(도메인 기반 디자인) 사상에 입각하여 도메인 영역에서의 이름은 반드시 도메인 언어를 사용해야하며, 기술기반의 이름을 사용해서는 안된다는 점을 반영한 것이다.


# 4. 컴포넌트 기반 패키지
***

계층형 아키텍처에서 영속성과 Service 인터페이스는 타 패키지에서 접근할 수 있어야하므로 public으로 선언한다. 이렇게 선언된 public은 가끔 문제를 야기시킨다.

![[Pasted image 20230319101115.png]]

새로운 기능 추가를 위해 Controller에서 OrderRepository를 직접 상속받아 특정 기능을 구현할 경우(Danger text) Service Layer를 거치지 않았다. 이는 계층형 구조로 인해 다른 패키지에서도 상속이 가능해야하기 때문에 public으로 선언자를 작성해둔 탓이다. 이를 보완한 것이 아래의 구조다.

![[Pasted image 20230319101306.png]]

위 구조는 컴포넌트 기반의 패키지구조를 표현한 것인데, 주문과 관련된 무엇인가를 해야 할 때는 OrdersComponent로만 접근한다. 업무로직과 영속성계층이 분리되어있고, 외부에서는 Orders의 영속성으로 직접 접근도 불가능하다.


위에서 아래로 갈수록 핵심업무규칙을 보호하는 패키지구조임을 나타낸다. 대규모 프로젝트에서는 이런 패키지구조를 결정할때에도 많은 고려가 필요하다. 

Interface 파일은 어차피 외부에 공개되는 경향이 있으니 접근제어자에 대해 생각해보지 않고 무조건 public으로하지말고 정말 public으로 설정을 해야하는지 고려해보아야한다. 