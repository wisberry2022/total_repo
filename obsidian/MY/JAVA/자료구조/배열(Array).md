

JAVA의 배열은 다른 언어에 비해 굉장히 잘 설계되었다. 배열 사용의 목적은 같은 자료형의 변수를 한 곳에 담아두고 사용하기 위함이다. 설계 목적 또한 사용목적과 동일하다.



## 0. 배열의 선언


```java

int[] arr = new int[5];
arr[0]=1;
arr[1]=3;
arr[2]=5;
arr[3]=7;
arr[4]=9;

```

`<자료형>[] 변수명 = new <자료형>[배열길이]` 와 같은 형식으로 배열을 선언 할 수 있다.  호출 할 때는 `배열명[인덱스]`를 통해 호출한다. 이러한 형태의 호출을 통해 값의 삽입, 확인이 가능하다. 

배열에서 사용하는 인덱스의 특징이 몇 가지 있다. 아래는 그것을 정리한 내용이다.

1. 0부터 출발한다.
2. 특정 인덱스를 생략하고 뛰어넘을 수 없다.
3. 마지막 인덱스는 '배열길이 - 1'이다.
4. 만약 배열의 인덱스보다 큰 숫자를 인덱스로 사용할 경우, `ArrayIndexOutBoundException` 에러가 발생한다.

배열 선언 시 가장 중요한 것은 변수 선언 시 자료형 선언과, 배열의 길이를 반드시 명세하여야한다. 이 점은 반드시 지켜야한다. 

배열의 경우, default값으로 초기화가 된다.

```java

int[] arr1 = new int[5];

for(int i = 0; i<arr1.length; i++) {
	System.out.print(arr1[i]);
}

```

위 코드의 경우 arr1 배열의 각 원소에는 0이 삽입된다. 

배열은 결국 참조변수다. 그렇기 때문에 초기화를 해주지 않으면 그 값으로 `null`이 사용된다.

배열의 선언 방법은 여러가지가 있다. 아래코드들을 보자.

```java

// case1
int[] arr1;
arr1 = new int[] {2,4,6,8};

// case2
int[] arr2 = new int[] {2,3,4};

// case3
int[] arr3={2,4,6,8};

// case4
int[] arr4;
arr1 = {2,4,6,8};

```

case1의 경우, 배열을 선언하고, 후에 초기화를 진행했다. 이 대 값을 한꺼번에 초기화하였다. case2의 경우 case1의 코드를 한 줄로 바꾼 것이다. case1과 case2의 경우 실제 값을 대입하였을 경우 그 사이즈를 대괄호 안에 작성하지 않는 것이 원칙이다. 만약 작성한다면 에러가 발생한다.

case3의 경우 권장되지 않는다. case3의 경우 실제 배열에 들어가는 값들의 자료형이 실제 int인지 보장되지 않는다. char 일수도 있으며 byte일 수도 있다.


### 0-1. 배열의 얕은 복사(Shallow Copy)

배열은 참조변수이다. 즉, 주소값을 가지고 데이터를 다루게 되는데, 원본 배열을 두고 다른 배열을 복사할 경우, 같은 객체를 가리키는 경우가 발생한다. 아래 코드를 보자.

```java

int[] arr1 = new int[] {1,2,3,4};
int[] arr2 = arr1;

```

새롭게 생성된 배열 arr2에 arr1을 대입했다. arr1과 arr2는 같은 객체를 바라보게 된다. 동일한 주소값을 가지고 있다는 의미다.

그래서 아래와 같은 코드를 작성하면 arr2도 원치않게 변경된다.

```java

arr1[2] = 10;

```

그렇다면 깊은 복사는 어떻게 진행할까? 간단하다. 새로운 배열을 생성하여 인덱스에 맞춰 원본 배열의 값을 하나하나 대입하면 된다.

```java

int[] arr1 = new int[] {1,2,3,4};
int[] arr2 = new int[4];

for(int i = 0; i<arr1.length; i++) {
	arr2[i] = arr1[i];
}

```

JAVA에서 배열의 깊은 복사를 위해 제공하는 메소드가 있다.

```java

int[] arr1 = new int[] {1,2,3,4,5};
int[] arr2 = new int[5];

System.arraycopy(arr1, 0, arr2, 0, 5);

```

arraycopy의 형태는 `arraycopy(Object src, int srcPos, Object target, int tarPos, int length)`의 형태로 사용한다. 첫 번째 인자에는 복사를 원하는 배열을, 두 번째 인자에는 첫 번째 인자에서 복사를 시작하고자 하는 인덱스를, 세 번째 인자에는 붙여넣기를 진행할 배열을, 네 번째 인자에는 세 번째 인자에서 붙여넣기를 시작하고자 하는 인덱스를, 마지막 인덱스에서는 복사를 원하는 개수를 int 값으로 전달한다.

얕은 복사는 메소드에 인자를 전달하면서도 자연스럽게 진행된다.

```java

public static void Copy(int[] arr) {
	arr[3] = 4;
}

public static void main(String[] args) {
	int[] arr1 = new int[] {1,2,3,4};
	Copy(arr1);

	for(int i = 0; i<arr1.length; i++) {
		System.out.print(arr1[i] + " ");
	}
}

```

Copy 메소드에 전달한 arr1 인자는 참조변수의 주소값이 전달되었다. 따라서 Copy 메소드 내부에서 인자로 받은 배열을 변경할 경우, 주소값을 통해 원본 객체의 인덱스가 바뀌어버린다. 그 결과 Copy 메소드를 빠져나와 arr1을 다시 확인했을 경우 Copy 메소드에서 이루어졌던 변경이 반영이 된다.

이러한 결과는 Copy 메소드 내부에서 자동으로 얕은 복사가 진행되었다. Copy 메소드에 진입했을 때, `arr = arr1`이 진행되었으니, 이는 얕은 복사가 진행된 것이다.


## 1. 배열의 길이 구하기

배열의 길이를 구하기 위해서는 JAVA에서 제공하는 메소드를 활용할 수 있다.

```java

int[] arr = new int[5];
System.out.print(arr.length);

```
