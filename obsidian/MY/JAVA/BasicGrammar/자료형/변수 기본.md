

## 0. 변수기본


JAVA에서 변수를 사용하는 것에는 일정한 규칙이 있다. 네이밍 규칙도 존재하지만 변수를 선언, 초기화하는 것에 특정한 규칙이 있다.

JAVA에서 변수는 한 번 할당하면 중복하여 같은 이름으로 선언, 할당 할 수 없다. 아래 코드는 불가능하다.

```java

int i = 10;
int i = 15;

```

i를 선언한다는 것은 특정 메모리 공간을 점유하게 되는 것이고, 앞으로 코드에서 i를 가리키면 기존에 마련한 특정 메모리 주소가 i가 되는 것이다. 하지만, 같은 이름의 변수를 또 다시 선언했다고 가정하자. 이 경우 또 다른 메모리 공간이 마련될 것이고, 향후 코드에서 i를 호출했을 때 해당 메모리 주소를 찾게 될 것이다. 그런데 이전에 i라고 선언한 메모리 공간이 있지 않았는가? 이럴 경우 자바는 두 번이나 할당된 i 중 어느 i를 선택해야 할 지 모르게 되는 문제가 발생한다.

위와 같은 이유로 같은 이름의 변수 선언은 금지된다.



## 1. 식별자

변수, 상수, 메소드, 배열, 문자열, 사용자가 정의하는 클래스나 메소드등을 구분할 수 있는 이름을 의미한다.

### 1-1. 식별자의 사용 원칙

식별자는 문자, 숫자, 특수문자로 구성될 수 있다. 하지만, 특수문자로 시작할 경우 그것은 특별한 경우에 사용되는 코드 컨벤션일 수도 있으니, 일반적인 경우 사용을 지양하는 것이 좋다. 
식별자의 첫 문자는 문자나 특수문자로 시작할 수 있다. 숫자는 사용 할 수 없다. 

- 예약어를 식별자로 사용할 수 없다.
- true, false, null은 식별자로 사용할 수 없다.
- 식별자는 길이에 제한을 두지 않는다.
- 같은 문자의 대소문자(Sum과 sum)는 서로 다른 식별자로 취급한다.


### 1-2. 식별자 명명법칙

일반적으로 Java를 활용하여 프로그래밍 할 때에는 식별자를 네이밍 할 때에는 아래 컨벤션을 지키는 것이 좋다.

클래스 이름
JavaTest1, RuntimeErrorTest -> 단어의 첫 글자는 대문자로 쓰는 것이 좋다.
applicationtest, sampletest -> 오류는 아니지만 관례에 어긋나고, 가독성이 떨어진다.

메소드, 변수, 배열, 문자열의 이름
sum, sumAndSubstract, nameAddress -> 단어의 첫 글자는 소문자로 쓰는 것이 좋다.
NameAndAge, Productname -> 좋지 않은 형태, 클래스 이름과 혼동된다.

상수의 이름
PI, MAX_NUMBER -> 상수는 모두 대문자로 쓰는 것이 관례이다.
max, Max, Address -> 상수가 아닌 다른 변수나, 클래스, 메소드와 혼동된다.

클래스의 이름은 파스칼 케이스, 메소드, 변수, 배열, 문자열의 이름은 카멜 케이스를, 상수의 경우는 모두 대문자로 작성하는 것이 좋다.



## 2. 변수 선언 시 메모리 상태

JAVA에서 변수를 선언하고 나면, JVM 메모리 중 한 영역에 변수가 저장된다. 이 때, JAVA의 자료형 타입에 따라 저장되는 영역에 차이가 있다.

JAVA는 두 가지 유형의 자료형을 가지고 있다. 원시 자료형(Primitive Data Type)과 참조 자료형(Reference Data Type)이 존재한다. 두 자료형 모두 JVM의 Stack 메모리에 쌓인다. 

원시 자료형의 경우 Stack 영역에 변수와 함께 저장되며, 참조 타입(Reference Type)은 Heap 영역에 객체 자체가 저장되고, Stack 영역에 있는 변수가 객체의 주소값을 갖고 있다. 

즉, 참조 타입의 경우 Stack 영역에 변수가 쌓이고, 그 변수는 Heap 영역에 존재하는 실질적인 객체의 주소값을 함께 가지고 있게 된다. 그리고 해당 변수를 수정하거나 특정 행동을 취할 경우 Heap 영역에 존재하는 실제 객체에 접근하게 된다.


## 3. 변수의 라이프 사이클

변수는 라이프 사이클을 가진다. 어디서 선언되었느냐에 따라, 해당 변수를 사용할 수 있는 범위 혹은 주기가 달라진다.

```java

for(int i = 0; i < 5; i++) {
	System.out.println(i);
}

```

위 반복문에서 변수 i는 for문 내부에서만 생명 주기를 가진다. for 문 내에서 선언되었기 때문에, for문 바깥에서는 변수 i를 제어할 수 없으며 확인할 수도 없다.

변수의 라이프 사이클은, 선언된 지역범위에서만 유효하다.

만약 지역변수와 전역변수가 함께 존재한다면, 지역 변수가 우선한다. 아래 코드를 보자.

```java

class Ex07 {
	public static int num = 1;

	public static void main(String[] args){
		int num = 2;
		System.out.println(num);
	}
}

```

static 변수 num은 JVM 메모리에서 클래스 영역의 static 영역에 저장된다. 반면 main 메소드의 num은 Stack 영역에 위치한다. 영역이 서로 다르기 때문에 변수명이 같다하더라도 오류가 발생하지 않는다. 만약 전역변수를 호출하고 싶다면 아래와 같이 코드를 작성해야한다.

```java

class Ex07 {
	public static int num = 1;

	public static void main(String[] args) {
		System.out.println(Ex07.num);
	}
}
```

지역변수와 전역변수의 구분을 위해서는 어느 영역에 있는 변수인지를 명시적으로 작성할 필요가 있다. 



## 4. 상수형 변수의 선언

변수를 선언할 때 초기화 이후 변경해서는 안되는 경우가 있을 수 있다. 이를 위해 JAVA에서는 final 키워드를 제공한다.

```java

final int su = 1111;
su = 2222;

```

위 코드는 에러를 발생시킨다. su 변수는 final로 선언되었으며, 1111로 할당됨과 동시에 이후에 재할당은 불가능하다.

하지만 아래와 같은 코드는 가능하다.

```java

final int su;
su=2222;

```

JAVA에서는 `final int su`를 선언(메모리 공간을 확보)하는 것이다. 이후 변수에 값을 할당하는 것은 문제가 되지 않는다. 

상수형 변수는 코드 컨벤션이 존재한다. 누구든지 상수형 변수임을 알 수 있도록 대문자로 작성하도록 한다.

```java

final int SU = 2222;

```

